/**
 * @file 05_LCS.cpp
 * @brief Dynamic programming
 * Longest Common Subsequence 最长公共子序列 (可能有多个，可能有歧义)
 * 
 * 递归：设计出可行且正确的解
 * 动态规划：消除重复计算，提高效率
 */


/**
 * @brief 递归
 * 对于序列 A[0, n] 和 B[0, m], LCS(A, B) 三种情况
 * 0) 若 n = -1 或 m = -1, 取空序列("")                                                     //递归基
 * 1) 若 A[n] = 'X' = B[m], 则取作 LCS(A[0, n), B[0, m)) + 'X'                              //减而治之  decrease
 * 2) 若 A[n] ≠ B[m]， 则在 LCS(A[0, n], B[0, m)) 和 LCS(A[0, n), B[0, m]) 中取更长者        //分而治之  divide 
 * 
 * 单调性: 无论如何，每经过一次比对，原问题的规模必可减小。具体地，作为输入的两个序列，至少其一的长度缩减为一个单位
 * 最好情况（不出现 2) 的情形）下，只有减而治之的情况下，只需 O(n+m)时间
 * 出现2 ) 的情形下），原问题将分解成为两个子问题，在随后进一步导出的子问题，可能雷同
 * 
 * 最坏情况下，LCS(A[0, a], B[0, b]) 出现的次数为 (n+m-a-b n-a) = (n+m-a-b m-b)
 * 特别的，LCS(A[0], B[0]) 出现的次数为 (n+m n) = (n+m m)  当 n=m时, 为O(2^n)
 */


/**
 * @brief 迭代
 * 与fib() 类似，这里也有大量重复的递归实例（子问题），最坏情况下 先后共计出现O(2^n)个
 * 各子问题分别对应A和B的某一个前缀组合，因此总共不会超过O(n×m)种
 * 采用动态规划的策略，只需O(n×m)时间即可计算出所有子问题
 * 
 * 将所有子问题（假想成）一张表，颠倒计算方向，从左上角LCS(A[0], B[0])出发依次计算所有项，直至LCS(n,m)
 */